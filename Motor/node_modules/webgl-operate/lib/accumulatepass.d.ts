import { GLsizei2 } from './tuples';
import { ChangeLookup } from './changelookup';
import { Context } from './context';
import { Framebuffer } from './framebuffer';
import { Initializable } from './initializable';
import { NdcFillingTriangle } from './ndcfillingtriangle';
import { Program } from './program';
import { Texture2D } from './texture2d';
import { Wizard } from './wizard';
/**
 * This pass accumulates the color attachment 0 of a framebuffer, e.g., the result of an intermediate frame, into an
 * accumulation buffer. For accumulation the frame number is used to derive the accumulation weight. For rendering to
 * texture, a textured ndc-filling triangle is used.
 *
 * The accumulation pass can be used as follows:
 * ```
 * this.accumulate.initialize();
 * this.accumulate.texture = this.intermediateFBO.texture(gl2facade.COLOR_ATTACHMENT0);
 * this.accumulate.update();
 * this.accumulate.frame(frameNumber);
 * ```
 */
export declare class AccumulatePass extends Initializable {
    /**
     * Read-only access to the objects context, used to get context information and WebGL API access.
     */
    protected _context: Context;
    /**
     * Alterable auxiliary object for tracking changes on this object's input and lazy updates.
     */
    protected readonly _altered: ChangeLookup & {
        any: boolean;
        texture: boolean;
        precision: boolean;
        passThrough: boolean;
    };
    /** @see {@link texture} */
    protected _texture: Texture2D;
    /** @see {@link precision} */
    protected _precision: Wizard.Precision;
    /** @see {@link passThrough} */
    protected _passThrough: boolean;
    /**
     * Two rgba-framebuffers used for accumulation (buffer ping-ponging is used for alternating the buffers for read
     * and write access due to a limitation in WebGL).
     */
    protected _accumulationFBOs: [Framebuffer, Framebuffer];
    protected _accumulationTextures: [Texture2D, Texture2D];
    /**
     * Stores the index of the last buffer written to.
     */
    protected _write: GLuint;
    /**
     * Geometry used to draw on. This is not provided by default to allow for geometry sharing. If no triangle is given,
     * the ndc triangle will be created and managed internally.
     */
    protected _ndcTriangle: NdcFillingTriangle;
    /**
     * Tracks ownership of the ndc-filling triangle.
     */
    protected _ndcTriangleShared: boolean;
    protected _program: Program;
    protected _uWeight: WebGLUniformLocation;
    constructor(context: Context);
    /**
     * Specializes this pass's initialization. This pass requires an ndc-filling triangle, a single accumulation
     * program, and two accumulation framebuffers for ping pong (simultaneous read and write is currently not allowed
     * by webgl). All attribute and dynamic uniform locations are cached.
     * @param ndcTriangle - If specified, assumed to be used as shared geometry. If none is specified, a ndc-filling
     * triangle will be created internally.
     */
    initialize(ndcTriangle?: NdcFillingTriangle): boolean;
    /**
     * Specializes this pass's uninitialization. Program and geometry resources are released (if allocated). Cached
     * uniform and attribute locations are invalidated.
     */
    uninitialize(): void;
    /**
     * Initialize accumulation textures and FBOs (if not initialized yet). Then verifies if the texture's size has
     * changed, and if so, resizes the accumulation buffers.
     */
    update(): void;
    /**
     * An accumulation frame binds the two accumulation textures (ping-pong framebuffer), one for read, the other for
     * write/accumulating into. A screen-aligned triangle is used to fill the viewport and mix the input texture with
     * the weight of 1 / (frameNumber + 1) with the previous accumulation result. If no texture is specified, pass
     * through is used.
     * @param frameNumber - Frame number used to select the current read and write framebuffer as well as frame weight.
     * @param viewport - If specified, the viewport for accumulation will be set to the given width and height. If not,
     * the currently set viewport is used.
     */
    frame(frameNumber: number, viewport?: GLsizei2): void;
    /**
     * Sets the texture that is to be accumulated. The ping and pong render textures will be resized on next frame
     * automatically if the texture size changed.
     * @param texture - Framebuffer that is to be accumulated.
     */
    set texture(texture: Texture2D);
    /**
     * Allows to specify the accumulation precision.
     */
    set precision(precision: Wizard.Precision);
    /**
     * Allows to skip accumulation. If pass through is enabled, nothing will be rendered on frame at all and the
     * ping pong render textures will be reduced to a minimum size of [1, 1] until pass through is disabled.
     */
    set passThrough(passThrough: boolean);
    /**
     * Returns the framebuffer last accumulated into. Note: the accumulation buffer is represented by two framebuffers
     * swapped for read and write every frame. The accumulation result is in the first color attachment.
     * @returns - The rgba framebuffer last accumulated into.
     */
    get framebuffer(): Framebuffer | undefined;
}
