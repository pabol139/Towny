import { mat4, vec3 } from 'gl-matrix';
import { Context } from './context';
import { Framebuffer } from './framebuffer';
import { Initializable } from './initializable';
import { NdcFillingTriangle } from './ndcfillingtriangle';
import { Program } from './program';
import { Texture2D } from './texture2d';
import { GLsizei2 } from './tuples';
/**
 * This stage provides means to sample G-Buffers, in order to give access to world space coordinates, depth values and
 * IDs. World space coordinates are calculated by sampling the depth value and unprojecting the normalized device
 * coordinates. Depth and ID values are read from the GPU by rendering the requested pixel to a 1x1 texture and reading
 * back the value from this texture. Note that depth and ID values are cached as long as no redraw (frame) was invoked.
 */
export declare class ReadbackPass extends Initializable {
    /**
     * Read-only access to the objects context, used to get context information and WebGL API access.
     */
    protected _context: Context;
    /** @see {@link cache} */
    protected _cache: boolean;
    /** @see {@link depthFBO} */
    protected _depthFBO: Framebuffer;
    /** @see {@link depthAttachment} */
    protected _depthAttachment: GLenum;
    /**
     * Cache providing previously read depth values for a given position hash.
     */
    protected _cachedDepths: Map<number, number | undefined>;
    /** @see {@link idFBO} */
    protected _idFBO: Framebuffer;
    /** @see {@link idAttachment} */
    protected _idAttachment: GLenum;
    /**
     * Cache providing previously read id values for a given position hash.
     */
    protected _cachedIDs: Map<number, number | undefined>;
    /**
     * Buffer to read into.
     */
    protected _buffer: Uint8Array;
    /**
     * Properties required for 24bit depth readback workaround. If a valid depth format is available as renderable
     * texture format, a single fragment is rasterized in order to encode the depth of at a specific location into
     * uint8x3 format, rendered into a RGBA texture for readback. This workaround is currently necessary since reading
     * back depth buffer data is not supported. All following protected properties are undefined when this workaround
     * is not required (i.e., in IE11), since the depth texture is already rendered explicitly in a previous render
     * pass.
     */
    protected _texture: Texture2D;
    protected _framebuffer: Framebuffer;
    /**
     * Coordinate reference size @see {@link coordinateReferenceSize}.
     */
    protected _referenceSize: GLsizei2 | undefined;
    /**
     * Geometry used to draw on. This is not provided by default to allow for geometry sharing. If no triangle is given,
     * the ndc triangle will be created and managed internally.
     */
    protected _ndcTriangle: NdcFillingTriangle;
    /**
     * Tracks ownership of the ndc-filling triangle.
     */
    protected _ndcTriangleShared: boolean;
    protected _program: Program;
    protected _uOffset: WebGLUniformLocation;
    protected _uScale: WebGLUniformLocation;
    /**
     * Read the the depth of a fragment in normalized device coordinates. The implementation of this function is
     * assigned at initialization based on the available WebGL features.
     * @param x - Horizontal coordinate for the upper left corner of the viewport origin.
     * @param y - Vertical coordinate for the upper left corner of the viewport origin.
     */
    readDepthAt: (x: GLsizei, y: GLsizei) => Uint8Array;
    /**
     * Returns the maximal depth value that can be encoded when using a uint8[3] - @see{@link depthAt}.
     */
    static maxClearDepth(): GLfloat;
    constructor(context: Context);
    /**
     * Frame implementation clearing depth and ID caches. To avoid unnecessary readbacks (potentially causing sync
     * points), the requested and found IDs and depths are cached by position. Hence, these cached values have to be
     * cleared whenever the framebuffers are written/rendered to.
     */
    protected onFrame(): void;
    /**
     * Create a numerical hash that can be used for efficient look-up (number preferred, no string for now). Note that
     * the implementation assumes that we do not exceed 65k pixel in horizontal or vertical resolution soon.
     * @param x - Horizontal coordinate from the upper left corner of the viewport origin.
     * @param y - Vertical coordinate from the upper left corner of the viewport origin.
     */
    protected hash(x: GLsizei, y: GLsizei): GLsizei;
    /**
     * Implements the direct readback of uint8x3 encoded depth values from a given framebuffer (see depthFBO and
     * depthAttachment).
     * @param x - Horizontal coordinate from the upper left corner of the viewport origin.
     * @param y - Vertical coordinate from the upper left corner of the viewport origin.
     * @returns - An array with 4 uint8 entries, the first three of which encode the depth.
     */
    protected directReadDepthAt(x: GLsizei, y: GLsizei): Uint8Array;
    /**
     * Implements the indirect readback of uint8x3 encoded depth values from a given framebuffer (see depthFBO and
     * depthAttachment). This renders a single pixel (1x1 pixel viewport) with the depth fbo as texture and reads this
     * afterwards. This is a fallback required when direct pixel read from depth attachments is not supported.
     * @param x - Horizontal coordinate for the upper left corner of the viewport origin.
     * @param y - Vertical coordinate for the upper left corner of the viewport origin.
     * @returns - An array with 4 uint8 entries, the first three of which encode the depth.
     */
    renderThenReadDepthAt(x: GLsizei, y: GLsizei): Uint8Array;
    /**
     * Specializes this pass's initialization. If required. ad screen-filling triangle geometry and a single program
     * are created. All attribute and dynamic uniform locations are cached.
     * @param ndcTriangle - If specified, assumed to be used as shared geometry. If none is specified, a ndc-filling
     * triangle will be created internally.
     * @param direct - If depth is already uint8x3 encoded into a rgb/rgba target no readback workaround is required.
     */
    initialize(ndcTriangle: NdcFillingTriangle | undefined, direct: boolean): boolean;
    /**
     * Specializes this stage's uninitialization. Program and geometry resources are released (if allocated). Cached
     * uniform and attribute locations are invalidated.
     */
    uninitialize(): void;
    /**
     * Retrieve the depth of a fragment in normalized device coordinates. The implementation of this function is
     * assigned at initialization based on the available WebGL features. Please note that in order to get the far plane
     * depth at just below 1.0, the clear depth should be set to:
     *     float24x1_from_uint8x3([255,255, 255]) = 0.9999999403953552
     * This will result in a readback of [255, 255, 255] and is the deepest depth value representable using a uint8x3.
     * Using 1.0 should result in [256, 0, 0] and would be easy to detect, however, it is somehow clamped to [255, 0, 0]
     * which is highly misleading and actual not nearly the far plane's depth. Thus, if [255, 255, 255] is read back,
     * undefined will be returned by this query and thereby reduce the effective depth range by 1 over 255^3 - sorry.
     * @param x - Horizontal coordinate for the upper left corner of the viewport origin.
     * @param y - Vertical coordinate for the upper left corner of the viewport origin.
     */
    depthAt(x: GLsizei, y: GLsizei): GLfloat | undefined;
    /**
     * Retrieving the world space coordinate of a fragment.
     * @param x - Horizontal coordinate for the upper left corner of the viewport origin.
     * @param y - Vertical coordinate for the upper left corner of the viewport origin.
     * @param zInNDC - optional depth parameter (e.g., from previous query).
     * @param viewProjectionInverse - matrix used to unproject the coordinate from ndc to world space.
     * @returns - The unprojected world space coordinate at location x, y.
     */
    coordsAt(x: GLsizei, y: GLsizei, zInNDC: number | undefined, viewProjectionInverse: mat4): vec3 | undefined;
    /**
     * Retrieve the id of an object at fragment position.
     * @param x - Horizontal coordinate for the upper left corner of the viewport origin.
     * @param y - Vertical coordinate for the upper left corner of the viewport origin.
     * @returns - The id rendered at location x, y.
     */
    idAt(x: GLsizei, y: GLsizei): GLsizei | undefined;
    /**
     * Invokes the frame implementation @see{@link onFrame}.
     */
    frame(): void;
    /**
     * Whether or not caching of requested depths and ids should be used to reduce performance impact.
     */
    set cache(value: boolean);
    /**
     * Sets the framebuffer object that is to be used for depth readback.
     * @param framebuffer - Framebuffer that is to be used for depth readback.
     */
    set depthFBO(framebuffer: Framebuffer);
    /**
     * Sets the framebuffer's {@link depthFBO} depth attachment that is to be used for depth readback.
     * @param attachment - Depth attachment that is to be used for depth readback.
     */
    set depthAttachment(attachment: GLenum);
    /**
     * Sets the framebuffer object that is to be used for id readback.
     * @param framebuffer - Framebuffer that is to be used for id readback.
     */
    set idFBO(framebuffer: Framebuffer);
    /**
     * Sets the framebuffer's {@link idFBO} id attachment that is to be used for id readback.
     * @param attachment - ID attachment that is to be used for id readback.
     */
    set idAttachment(attachment: GLenum);
    /**
     * Sets the coordinate-reference size that is, if not undefined, used to scale incomming x and y coordinates.
     * @param size - Size of the output, e.g., the canvas, the buffer is rendered to.
     */
    set coordinateReferenceSize(size: GLsizei2 | undefined);
}
