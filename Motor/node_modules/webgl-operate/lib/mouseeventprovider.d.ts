import { Observable, ReplaySubject } from 'rxjs';
export declare class MouseEventProvider {
    /**
     * HTML canvas element within the HTML5 document to register event listeners to.
     */
    protected _element: HTMLCanvasElement;
    /**
     * Time frame for events to be buffered (windowTime in rxjs per ReplaySubject).
     */
    protected _timeframe: number | undefined;
    protected _clickListener: {
        (event: MouseEvent): void;
    };
    protected _clickSubject: ReplaySubject<MouseEvent>;
    protected _enterListener: {
        (event: MouseEvent): void;
    };
    protected _enterSubject: ReplaySubject<MouseEvent>;
    protected _leaveListener: {
        (event: MouseEvent): void;
    };
    protected _leaveSubject: ReplaySubject<MouseEvent>;
    protected _downListener: {
        (event: MouseEvent): void;
    };
    protected _downSubject: ReplaySubject<MouseEvent>;
    protected _upListener: {
        (event: MouseEvent): void;
    };
    protected _upSubject: ReplaySubject<MouseEvent>;
    protected _moveListener: {
        (event: MouseEvent): void;
    };
    protected _moveSubject: ReplaySubject<MouseEvent>;
    protected _wheelListener: {
        (event: WheelEvent): void;
    };
    protected _wheelSubject: ReplaySubject<WheelEvent>;
    protected _dragListener: {
        (event: DragEvent): void;
    };
    protected _dragSubject: ReplaySubject<DragEvent>;
    /** @see {@link pointerLock} */
    protected _pointerLockRequestPending: boolean;
    /**
     * This mask saves for which types of events, event.preventDefault should be called. This is useful to disallow
     * some kinds of standard events like scrolling or clicking on links.
     */
    protected _preventDefaultMask: MouseEventProvider.Type;
    constructor(element: HTMLCanvasElement, timeframe?: number);
    /**
     * The pointer lock API requires a little workaround in order to avoid something like '... not called from inside a
     * short running user-generated event handler'. A click event listener is registered and whenever a pointer lock is
     * requested, e.g., from an event handler (which in turn exposes this interface to, e.g., a navigation), the next
     * click will result in a probably more successful pointer lock.
     */
    protected processPointerLockRequests(): void;
    /**
     * Checks whether or not to prevent the default handling of the given event. This depends on the internal
     * `preventDefaultMask` which can be modified using `preventDefault` function @see{@link preventDefault}.
     * @param type - Internal event type of the incoming event.
     * @param event - Actual event to prevent default handling on (if masked).
     */
    protected preventDefaultOnEvent(type: MouseEventProvider.Type, event: MouseEvent): void;
    /**
     * Prevent default event handling on specific event types (using preventDefault on the event).
     * @param types - Event types to prevent default handling on.
     */
    preventDefault(...types: MouseEventProvider.Type[]): void;
    /**
     * Allow default event handling on specific event types (not calling preventDefault on the event).
     * @param types - Event types to allow default handling on.
     */
    allowDefault(...types: MouseEventProvider.Type[]): void;
    observable(type: MouseEventProvider.Type): Observable<MouseEvent> | Observable<WheelEvent> | Observable<DragEvent> | undefined;
    /**
     * Enable/disable pointer lock on click. If true, the next click on this event provider's canvas will invoke a
     * pointer lock request on the canvas element.
     */
    set pointerLock(lock: boolean);
    get pointerLock(): boolean;
    get click$(): Observable<MouseEvent>;
    get enter$(): Observable<MouseEvent>;
    get leave$(): Observable<MouseEvent>;
    get down$(): Observable<MouseEvent>;
    get up$(): Observable<MouseEvent>;
    get move$(): Observable<MouseEvent>;
    get wheel$(): Observable<WheelEvent>;
    get drag$(): Observable<DragEvent>;
}
export declare namespace MouseEventProvider {
    enum Type {
        Click = 1,
        Wheel = 2,
        Enter = 4,
        Leave = 8,
        Move = 16,
        Down = 32,
        Up = 64,
        Drag = 128
    }
}
