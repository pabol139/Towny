import { EyeGazeEvent } from './eyegazeevent';
export declare class EyeGazeEventTarget extends EventTarget {
}
export declare class EyeGazeDataStream {
    static readonly EYE_GAZE_DATA = "eyegazedata";
    static readonly NEW_SERVER_MESSAGE = "newservermessage";
    static readonly CONNECTION_STATUS = "connectionstatus";
    static readonly BINARY_MESSAGE_PARSING_ERROR = "binarymessageparsingerror";
    static readonly SUCCESSFULLY_CONNECTED_TO_SERVER = "successfully connected to server";
    static readonly DISCONNECTED_TO_SERVER = "disconnected to server";
    static readonly CONNECTION_ERROR = "connection error with server";
    protected _webSocket: WebSocket;
    protected _eyeGazeDataStreams: EyeGazeDataStreams;
    protected _eyeGazeEventTarget: EventTarget;
    protected generateStreamConfigByte(): Uint8Array;
    protected performHandshake(): void;
    protected parseEyeTrackingData(data: Float32Array): EyeGazeEvent;
    protected onOpen(event: Event): void;
    protected onClose(event: Event): void;
    protected onError(event: Event): void;
    protected onMessage(event: MessageEvent): Promise<void>;
    connect(serverAddress: string): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject | undefined, options?: boolean | AddEventListenerOptions): void;
    dispatchEvent(event: Event): boolean;
    removeEventListener(type: string, callback: EventListenerOrEventListenerObject | undefined, options?: EventListenerOptions | boolean): void;
    get connectionState(): number;
    get eyeGazeDataStreams(): EyeGazeDataStreams;
    set eyeGazeDataStreams(eyeGazeDataStreams: EyeGazeDataStreams);
}
export declare class EyeGazeDataStreams {
    gazePosition: boolean;
    gazeOrigin: boolean;
    eyePositionNormalized: boolean;
    headPositionAndRotation: boolean;
    userPresence: boolean;
    expectedNumberOfFloats: number;
    recalculateNumberOfFloats(): void;
}
