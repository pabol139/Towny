import { Canvas } from './canvas';
declare let MediaRecorder: any;
declare type CanvasCaptureMediaStream = any;
declare type MediaRecorder = any;
declare type ImagesAvailableCallback = (images: Array<Blob>) => void;
/**
 * Class to record the contents of a Canvas.
 * Some time after stopping the CanvasRecorder the recorded images will be available as Array of Blobs. The images can
 * be retrieved by setting the onImagesAvailable callback.
 * Exemplary usage:
 * ```
 * const recorder = new gloperate.CanvasRecorder(canvas);
 * recorder.start(30, 'video/webm', 2.0 * 2**20);
 * ...
 * recorder.stop();
 * recorder.download();
 * ```
 */
export declare class CanvasRecorder {
    protected _canvas: Canvas;
    protected _stream: CanvasCaptureMediaStream;
    protected _recorder: MediaRecorder;
    protected _state: CanvasRecorder.State;
    protected _images: Array<Blob>;
    protected _mimeType: string;
    protected _onImagesAvailable: ImagesAvailableCallback | undefined;
    /**
     * Checks whether recording the canvas is supported.
     */
    static isSupported(): boolean;
    /**
     * Checks whether the given MIME type is supported.
     * @param type - MIME type to check.
     */
    static isMIMETypeSupported(type: string): boolean;
    /**
     * Creates a CanvasRecorder. Throws, if it is not supported on the used platform.
     * @param canvas - The canvas to record.
     */
    constructor(canvas: Canvas);
    /**
     * Starts recording the the canvas. If the given fps is 0 it won't automatically record. Instead {@link frame} has
     * to be called every time a new frame should get recorded. Must not be called with negative fps, while already
     * recording or with an unsupported MIME type.
     * @param fps - Maximum fps to record in.
     * @param mimeType - The MIME video type.
     */
    start(fps: number, mimeType?: string, bitsPerSecond?: number): void;
    /**
     * Stops recording the canvas. Must not be called while not already recording.
     */
    stop(): void;
    /**
     * Pauses recording. Can be later resumed with {@link resume}.
     * Must not be called while not already recording.
     */
    pause(): void;
    /**
     * Resumes recording.
     * Must not be called while not already recording.
     */
    resume(): void;
    /**
     * Explicitly records a single frame from the canvas. This can be used when {@link start} was called with fps = 0.
     */
    frame(): void;
    /**
     * Creates a temporary hyperlink element and triggers a download of the blob with the given file name. Both, the
     * hyperlink element and the blob url are removed automatically shortly after the hyperlink click was triggered.
     */
    download(fileName: string): void;
    /**
     * Returns the recorded images. Note: Images are not necessarily immediately available after stopping.
     */
    get images(): Array<Blob>;
    /**
     * Returns the state the CanvasRecorder currently is in.
     */
    get state(): CanvasRecorder.State;
    /**
     * Returns a new blob of all recorded, available images.
     */
    get blob(): Blob;
    /**
     * Sets the onImagesAvailable callback.
     */
    set onImagesAvailable(callback: ImagesAvailableCallback);
}
export declare namespace CanvasRecorder {
    enum State {
        INACTIVE = 0,
        RECORDING = 1,
        PAUSED = 2
    }
}
export {};
