import { Camera } from './camera';
import { EventHandler } from './eventhandler';
import { Invalidate } from './renderer';
import { FirstPersonModifier } from './firstpersonmodifier';
import { PanModifier } from './panmodifier';
import { PinchZoomModifier } from './pinchzoommodifier';
import { TrackballModifier } from './trackballmodifier';
import { TurntableModifier } from './turntablemodifier';
import { EventProvider } from './eventhandler';
import { WheelZoomModifier } from './wheelzoommodifier';
/**
 * This navigation is merely a design template/recipe for more refined, specialized navigation and provides some basic,
 * commonly used camera modifier such as turntable, first-person, as well as trackball. This implementation is also
 * unfinished and will be continued as soon as possible (e.g., first-person navigation is not usable for now).
 * @todo - Refine and comment this class to be usable at least as common/most-basic navigation auxiliary.
 */
export declare class Navigation {
    /**
     * The navigation's invalidation callback. This should usually be setup by the owning renderer and invoke the
     * same callback the renderer has been given by the canvas. This invalidation is required, when continuous
     * rendering is not present, events might cause need for new rendering requests.
     */
    protected _invalidate: Invalidate;
    /** @see {@link camera} */
    protected _camera: Camera;
    /**
     * Currently active metaphor.
     */
    protected _rotationMetaphor: Navigation.RotationMetaphor;
    /**
     * Identifies the active camera modifier.
     */
    protected _mode: Navigation.Modes | undefined;
    /**
     * Specifies, whether or not rotation mode should be invoked on any move event, regardless of buttons.
     */
    protected _alwaysRotateOnMove: boolean;
    /**
     * First person camera modifier.
     */
    protected _firstPerson: FirstPersonModifier | undefined;
    /**
     * Trackball camera modifier.
     */
    protected _trackball: TrackballModifier | undefined;
    /**
     * Turntable camera modifier.
     */
    protected _turntable: TurntableModifier | undefined;
    /**
     * Pan camera modifier.
     */
    protected _pan: PanModifier;
    /**
     * Pinch camera modifier.
     */
    protected _pinch: PinchZoomModifier;
    /**
     * Wheel zoom modifier.
     */
    protected _wheelZoom: WheelZoomModifier;
    /**
     * Even handler used to forward/map events to specific camera modifiers.
     */
    protected _eventHandler: EventHandler;
    /**
     * This keeps track of all events that are currently interacting with the canvas.
     * It maps from pointer id to the currecnt position.
     */
    protected _activeEvents: Map<number, PointerEvent>;
    /**
     * Keep track of the latest interaction in order to allow a cooldown before the next
     * interaction is allowed.
     */
    protected _lastInteractionTime: number;
    constructor(invalidate: Invalidate, eventProvider: EventProvider);
    /**
     * Resolves the event to camera modifier mapping by returning the responsible camera modifier.
     * @param event - Event to retrieve navigation mode for.
     */
    protected mode(): Navigation.Modes | undefined;
    protected resolveMultiTouch(): Navigation.Modes | undefined;
    protected rotate(start: boolean): void;
    protected pan(start: boolean): void;
    protected pinch(start: boolean): void;
    protected getPrimaryEvent(events: Array<PointerEvent>): PointerEvent | undefined;
    protected onPointerDown(latests: Array<PointerEvent>, previous: Array<PointerEvent>): void;
    protected onPointerUp(latests: Array<PointerEvent>, previous: Array<PointerEvent>): void;
    protected onPointerEnter(latests: Array<PointerEvent>, previous: Array<PointerEvent>): void;
    protected onPointerLeave(latests: Array<PointerEvent>, previous: Array<PointerEvent>): void;
    protected onPointerCancel(latests: Array<PointerEvent>, previous: Array<PointerEvent>): void;
    protected onPointerMove(latests: Array<PointerEvent>, previous: Array<PointerEvent>): void;
    protected onWheel(latests: Array<WheelEvent>, previous: Array<WheelEvent>): void;
    /**
     * Update should invoke navigation specific event processing. When using, e.g., an event handler, the event handlers
     * update method should be called in order to have navigation specific event processing invoked.
     */
    update(): void;
    /**
     * The camera that is to be modified in response to various events.
     */
    set camera(camera: Camera);
    /**
     * Configure this navigation's metaphor.
     */
    set rotationMetaphor(metaphor: Navigation.RotationMetaphor);
    get rotationMetaphor(): Navigation.RotationMetaphor;
}
export declare namespace Navigation {
    /**
     * Navigation modes used for identification of the current navigation intend, which is derived based on the event
     * types or gestures, regardless of the active navigation metaphor and its constraints.
     */
    enum Modes {
        Move = 0,
        Pan = 1,
        /**
         * MultiTouch is used when interaction with two fingers was initiated but it is not clear yet what
         * interaction the user intends
         */
        MultiTouch = 2,
        Rotate = 3,
        Zoom = 4,
        ZoomStep = 5
    }
    /**
     * Navigation metaphors supported by the default navigation implementation.
     */
    enum RotationMetaphor {
        FirstPerson = "firstperson",
        Flight = "flight",
        Trackball = "trackball",
        Turntable = "turntable"
    }
}
