import { Bindable } from './bindable';
import { TexImage2DData } from './gl2facade';
import { AbstractObject } from './object';
/**
 * Wrapper for an WebGL cube texture providing size accessors and requiring for bind, unbind, resize, validity, and
 * initialization implementations. The texture cube object is created on initialization and deleted on uninitialization.
 * After being initialized, the texture cube can be resized, reformated, and data can set directly or via fetch:
 * ```
 * const cubeMap = new TextureCube(context, 'CubeMap');
 * cubeMap.initialize(512, gl.RGB8, gl.RGB, gl.UNSIGNED_BYTE);
 * cubeMap.fetch({
 *     positiveX: 'data/cubemap.px.png', negativeX: 'data/cubemap.nx.png',
 *     positiveY: 'data/cubemap.py.png', negativeY: 'data/cubemap.ny.png',
 *     positiveZ: 'data/cubemap.pz.png', negativeZ: 'data/cubemap.nz.png',
 * }).then(() => this.invalidate(true);
 * ```
 * Please note that each of the six textures of a texture cube is required to be of the exact same, square dimensions.
 * This is reflected within this classes interface by providing a single size property in favor to width and height.
 */
export declare class TextureCube extends AbstractObject<WebGLTexture> implements Bindable {
    /**
     * Default texture, e.g., used for unbind.
     */
    static readonly DEFAULT_TEXTURE: undefined;
    /** @see {@link size} */
    protected _size: GLsizei;
    /** @see {@link internalFormat} */
    protected _internalFormat: GLenum;
    /** @see {@link format} */
    protected _format: GLenum;
    /** @see {@link type} */
    protected _type: GLenum;
    /**
     * For tracking approximate use of GPU storage in bytes per face.
     */
    protected _bytes: Array<GLsizei>;
    /**
     * Provides an ID for each of the six texture cube identifier (0: +x, 1: -x, 2: +y, 3: -y, 4: +z, 5: -z).
     * @param face - Texture cube face identifier, e.g., `TEXTURE_CUBE_MAP_POSITIVE_X`.
     * @returns - Face ID in the following sequence: 0: +x, 1: -x, 2: +y, 3: -y, 4: +z, 5: -z.
     */
    protected faceID(face: GLenum): GLint;
    /**
     * Create a texture object on the GPU.
     * @param size - Initial size (width/height) of each face, which are required to be a square texture.
     * @param internalFormat - Internal format of the texture object.
     * @param format - Format of the texture data even though no data is passed.
     * @param type - Data type of the texel data.
     */
    protected create(size: GLsizei, internalFormat: GLenum, format: GLenum, type: GLenum): WebGLTexture | undefined;
    /**
     * Delete the texture object on the GPU. This should have the reverse effect of `create`.
     */
    protected delete(): void;
    /**
     * Crops the contents of an image and returns a ImageData element of the resulting image.
     * Offsets and sizes of the cropping range need to be supplied. The resulting image data will
     * have the same height and width as the crop size.
     */
    protected cropImage(srcImage: HTMLImageElement, offsetX: number, offsetY: number, width: number, height: number): ImageData;
    /**
     * Loads one mip map level from a texture atlas in which all mipmap levels of a cubemap are stored.
     * The format is assumed to be NX, PZ, PX, NZ in the top row and PY, NY in the bottom row.
     * The bottom right quarter is assumed to be the next lower mipmap level. This repeats until the highest mipmap
     * level is reached.
     * @param image - Source texture atlas.
     * @param mipLevel - Level to load.
     */
    protected extractMipLevelFromAtlas(image: HTMLImageElement, mipLevel: number): void;
    /**
     * Bind the texture object to a texture unit.
     */
    bind(unit?: GLenum): void;
    /**
     * Unbind the texture object from a texture unit.
     */
    unbind(unit?: GLenum): void;
    /**
     * Asynchronous load of multiple images (specified per texture cube face) via URI or data URI. Please note
     * that the texture will not be resized and is assumed to be resized upfront accordingly.
     * @param urisByFace - URI linking the image that should be loaded for a specific face. Data URI is also supported.
     * @param crossOrigin - Enable cross origin data loading.
     * @returns - Promise for handling images load status.
     */
    fetch(urisByFace: TextureCube.PerFaceURI, crossOrigin?: boolean, mipLevel?: number): Promise<void>;
    /**
     * Asynchronously loads a cubemap and its mipmap levels from a single texture atlas.
     * The format is assumed to be NX, PZ, PX, NZ in the top row and PY, NY in the bottom row.
     * The bottom right quarter is assumed to be the next lower mipmap level. This repeats until the highest mipmap
     * level is reached.
     * @param uri - URI linking the texture atlas that should be loaded.
     * @param crossOrigin - Enable cross origin data loading.
     */
    fetchMipmapAtlas(uri: string, crossOrigin?: boolean): Promise<void>;
    /**
     * This function returns how big a specific mip level for this cubemap hast to be.
     * @param level - The level for which the size should be determined
     */
    calculateMipLevelSize(level: number): number;
    /**
     * Pass data of six images to the texture cube object.
     * @param data - Per face texel data that will be copied into the objects data store. Either provided via object
     * or as tuple, providing the data associated to the targeted face (as GLenum).
     * @param bind - Allows to skip binding the texture (e.g., when binding is handled outside).
     * @param unbind - Allows to skip unbinding the texture (e.g., when binding is handled outside).
     */
    data(data: TextureCube.PerFaceData | [GLenum, TexImage2DData], mipLevel?: number, bind?: boolean, unbind?: boolean): void;
    /**
     * Sets the texture object's magnification and minification filter.
     * @param mag - Value for the TEXTURE_MAG_FILTER parameter.
     * @param min - Value for the TEXTURE_MIN_FILTER parameter.
     * @param bind - Allows to skip binding the texture (e.g., when binding is handled outside).
     * @param unbind - Allows to skip unbinding the texture (e.g., when binding is handled outside).
     */
    filter(mag: GLenum, min: GLenum, bind?: boolean, unbind?: boolean): void;
    /**
     * Sets the texture object's wrapping function for s and t coordinates.
     * @param wrap_s - Value for the TEXTURE_WRAP_S parameter.
     * @param wrap_t - Value for the TEXTURE_WRAP_T parameter.
     * @param bind - Allows to skip binding the texture (e.g., when binding is handled outside).
     * @param unbind - Allows to skip unbinding the texture (e.g., when binding is handled outside).
     */
    wrap(wrap_s: GLenum, wrap_t: GLenum, bind?: boolean, unbind?: boolean): void;
    /**
     * Set the textures base and max level for mip mapping. This needs to be used when mip levels
     * are uploaded manually to specifiy how many mip levels exist.
     * @param baseLevel - The level with the maximal resolution, usually this will be 0.
     * @param maxLevel - The level with the minimal resolution.
     * @param bind - Allows to skip binding the texture (e.g., when binding is handled outside).
     * @param unbind - Allows to skip unbinding the texture (e.g., when binding is handled outside).
     */
    levels(baseLevel: number, maxLevel: number, bind?: boolean, unbind?: boolean): void;
    /**
     * This can be used to reformat the texture image without creating a new texture object. Please note that this
     * resets the texture's image data to undefined. @see {@link data} for setting new image data.
     * @param internalFormat - Internal format of the texture object.
     * @param format - Format of the texture data even though no data is passed.
     * @param type - Data type of the texel data.
     * @param bind - Allows to skip binding the texture (e.g., when binding is handled outside).
     * @param unbind - Allows to skip unbinding the texture (e.g., when binding is handled outside).
     */
    reformat(internalFormat: GLenum, format?: GLenum, type?: GLenum, bind?: boolean, unbind?: boolean): void;
    /**
     * This should be used to efficiently resize the texture.
     * @param size - Targeted/new size (width/height) of the texture in px.
     * @param bind - Allows to skip binding the texture (e.g., when binding is handled outside).
     * @param unbind - Allows to skip unbinding the texture (e.g., when binding is handled outside).
     */
    resize(size: GLsizei, bind?: boolean, unbind?: boolean): void;
    /**
     * Returns the number of bytes this object approximately allocates on the GPU. The size will be zero when no
     * image data was passed to the texture object.
     */
    get bytes(): GLsizei;
    /**
     * Cached internal format of the texture for efficient resize. This can only be changed by re-initialization.
     */
    get internalFormat(): GLenum;
    /**
     * Cached format of the data provided to the texture object for efficient resize. This is set on initialization and
     * might change on data transfers.
     */
    get format(): GLenum;
    /**
     * Cached type of the data provided to the texture used for efficient resize. This is set on initialization and
     * might change on data transfers.
     */
    get type(): GLenum;
    /**
     * The width/height of the texture object (each cube map face is required to be a square).
     */
    get size(): GLsizei;
}
export declare namespace TextureCube {
    interface PerFaceURI {
        positiveX?: string;
        negativeX?: string;
        positiveY?: string;
        negativeY?: string;
        positiveZ?: string;
        negativeZ?: string;
    }
    interface PerFaceData {
        positiveX?: TexImage2DData;
        negativeX?: TexImage2DData;
        positiveY?: TexImage2DData;
        negativeY?: TexImage2DData;
        positiveZ?: TexImage2DData;
        negativeZ?: TexImage2DData;
        clearOnUndefined: boolean;
    }
}
