import { LogLevel } from './auxiliaries';
import { AllocationRegister } from './allocationregister';
import { ContextMasquerade } from './contextmasquerade';
import { GL2Facade } from './gl2facade';
/**
 * A controller for either a WebGLRenderingContext or WebGL2RenderingContext. It requests a context, tracks context
 * attributes, extensions as well as multi frame specific rendering information and a (gpu)allocation registry.
 *
 * An instance of `Context` can be created only implicitly by requesting a context given a canvas element and its
 * dataset:
 * ```
 * const element: HTMLCanvasElement = <HTMLCanvasElement>document.getElementById(canvasID);
 * this.context = Context.request(element); // element.dataset is used for attributes
 * ```
 * The context supports the following data-attributes:
 * ```
 * data-backend: 'auto' | 'webgl' | 'webgl2'
 * data-accumulation-format: 'auto' | 'float' | 'half' | 'byte'
 * ```
 *
 * At run-time, cached context features can be queried without a performance impact, e.g., frequent extension-based
 * branching:
 * ```
 * if(this.context.supportsVertexArrayObject) {
 *     this.context.vertexArrayObject.bindVertexArrayOES(...);
 *     ...
 * }
 * ```
 *
 * For convenience, protected extension names such as `EXT_frag_depth` are not prefixed by an underscore.
 */
export declare class Context {
    /**
     * Context creation attribute defaults. The defaults are taken directly from the spec.
     */
    protected static readonly DEFAULT_ATTRIBUTES: {
        alpha: boolean;
        antialias: boolean;
        depth: boolean;
        failIfMajorPerformanceCaveat: boolean;
        premultipliedAlpha: boolean;
        preserveDrawingBuffer: boolean;
        stencil: boolean;
    };
    /** @see {@link backend} */
    protected _backend: Context.BackendType | undefined;
    /**
     * Created context. The actual type depends on the created context.
     * @see {@link gl}
     */
    protected _context: WebGLRenderingContext | WebGL2RenderingContext | undefined;
    /** @see {@link mask} */
    protected _mask: ContextMasquerade | undefined;
    /** @see {@link gl2facade} */
    protected _gl2: GL2Facade;
    /**
     * Creates a masquerade object that can be used for debugging. This is intended to be called when requesting a
     * context, i.e., before actually requesting it. For creation of a masquerade object, the following masquerade
     * specifiers are evaluated in the following order:
     *  1. msqrd_h GET parameter,
     *  2. msqrd_p GET parameter,
     *  3. data-msqrd-h attribute of the canvas element, and, finally,
     *  4. data-msqrd-p attribute of the canvas element.
     * If no specifier can be found, no object is created and undefined is returned.
     * @param dataset - Dataset of the canvas element that might provide a data-msqrd-{h,p} attribute.
     * @returns - Masquerade object when a specifier was found. If none was found undefined is returned.
     */
    protected static createMasqueradeFromGETorDataAttribute(dataset: DOMStringMap): ContextMasquerade | undefined;
    /**
     * Create a WebGL context. Note: this should only be called once in constructor, because the second and subsequent
     * calls to getContext of an element will return null.
     * @param element - Canvas element to request context from.
     * @param attributes - Overrides the internal default attributes @see{Context.DEFAULT_ATTRIBUTES}.
     * @returns - Context providing either a WebGLRenderingContext, WebGL2RenderingContext.
     */
    static request(element: HTMLCanvasElement, attributes?: WebGLContextAttributes): Context;
    /**
     * Helper that tries to create a WebGL 1 context (requests to 'webgl' and 'experimental-webgl' are made).
     * @param element - Canvas element to request context from.
     * @param attributes - Overrides the internal default attributes @see{Context.CONTEXT_ATTRIBUTES}.
     * @returns {WebGLRenderingContext} - WebGL context object or null.
     */
    protected static requestWebGL1(element: HTMLCanvasElement, attributes?: WebGLContextAttributes): WebGLRenderingContext | undefined;
    /**
     * Helper that tries to create a WebGL 2 context (requests to 'webgl2' and 'experimental-webgl2' are made).
     * @param element - Canvas element to request context from.
     * @param attributes - Overrides the internal default attributes @see{Context.CONTEXT_ATTRIBUTES}.
     * @returns {WebGL2RenderingContext} - WebGL2 context object or undefined.
     */
    protected static requestWebGL2(element: HTMLCanvasElement, attributes?: WebGLContextAttributes): WebGL2RenderingContext | undefined;
    /**
     * Cached attributes of the context.
     */
    protected _attributes: WebGLContextAttributes | undefined;
    protected queryAttributes(): void;
    /**
     * @link https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.2
     * If the value is true, the drawing buffer has an alpha channel for the purposes of performing OpenGL destination
     * alpha operations and compositing with the page. If the value is false, no alpha buffer is available.
     */
    get alpha(): boolean;
    /**
     * @link https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.2
     * If the value is true and the implementation supports antialiasing the drawing buffer will perform antialiasing
     * using its choice of technique (multisample/supersample) and quality. If the value is false or the implementation
     * does not support antialiasing, no antialiasing is performed.
     */
    get antialias(): boolean;
    /**
     * @link https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.2
     * If the value is true, the drawing buffer has a depth buffer of at least 16 bits. If the value is false, no depth
     * buffer is available.
     */
    get depth(): boolean;
    /**
     * @link https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.2
     * If the value is true, context creation will fail if the implementation determines that the performance of the
     * created WebGL context would be dramatically lower than that of a native application making equivalent OpenGL
     * calls...
     */
    get failIfMajorPerformanceCaveat(): boolean;
    /**
     * @link https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.2
     * If the value is true the page compositor will assume the drawing buffer contains colors with premultiplied alpha.
     * If the value is false the page compositor will assume that colors in the drawing buffer are not premultiplied.
     * This flag is ignored if the alpha flag is false. See Premultiplied Alpha for more information on the effects of
     * the premultipliedAlpha flag.
     */
    get premultipliedAlpha(): boolean;
    /**
     * @link https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.2
     * If false, once the drawing buffer is presented as described in theDrawing Buffer section, the contents of the
     * drawing buffer are cleared to their default values. All elements of the drawing buffer (color, depth and stencil)
     * are cleared. If the value is true the buffers will not be cleared and will preserve their values until cleared
     * or overwritten by the author.
     */
    get preserveDrawingBuffer(): boolean;
    /**
     * @link https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.2
     * If the value is true, the drawing buffer has a stencil buffer of at least 8 bits. If the value is false, no
     * stencil buffer is available.
     */
    get stencil(): boolean;
    /**
     * Cached extension supported by the context.
     */
    protected _extensions: Array<string>;
    /**
     * Checks if the given extension is supported. Please note that a 'supports' call asserts whether or not the
     * extension is related to the WebGL version. For example, the following code would lead to an Error:
     * ```
     * this.supports('ANGLE_instanced_arrays'); // asserts in WebGL2 since the extension is incorporated by default
     * ```
     * If the context is masked by a ContextMasquerade the support of an extension might be concealed.
     * @param extension - Extension identifier to query support for.
     * @returns - True if the extension is supported, false otherwise.
     */
    supports(extension: string): boolean;
    /**
     * Enable provided extensions. Each extension is only enabled if it is supported. Alternatively the extension can
     * be queried for support and accessed (thereby enabled) directly. Thus, this function only acts as convenience
     * interface for something like a mandatory extension configuration etc. Also, some extensions only effect GLSL
     * capabilities and must be enabled explicitly without accessing the extension object.
     * @param extensions - Array of extensions identifier that are to be enabled.
     */
    enable(extensions: Array<string>): void;
    /**
     * Queries all extensions for the current context and stores the result (supported or not supported). This is
     * relevant to avoid continuous searches or regexp matching or substring queries in the complete extension string.
     * Instead, the support is queried once and can be explicitly request in the public interface using properties.
     *
     * This function should get called only once per Context instance.
     */
    protected queryExtensionSupport(): void;
    /**
     * Returns the cached extensions object for the given extension identifier. If no extensions is cached, it is
     * queried. Asserts if the extension is provided by default in the current backend, not supported in general, or
     * unknown to the specification.
     * Please not that the availability of an extension might be concealed by the context's mask.
     * @param out - Member the extension object is cached into.
     * @param extension - Extension identifier to query.
     * @returns - Extension object.
     */
    protected extension(out: any, extension: string): any;
    /**
     * Context this is of type 'any' for now, since WebGL2RenderingContext not available but supported. This
     * constructor is protected to enforce context creation using `request`. It queries extension support and
     * configures context specifics for convenience, e.g., HALF_FLOAT format.
     */
    protected constructor(context: any, mask: ContextMasquerade | undefined);
    /** @see {@link allocationRegister} */
    protected _allocationRegister: AllocationRegister;
    /**
     * The context's GPU allocation register for use of tracking memory allocations.
     */
    get allocationRegister(): AllocationRegister;
    /**
     * The created rendering backend (webgl context type), either 'webgl' or 'webgl2' based on which one was
     * created successfully. If no context could be created undefined is returned.
     * @returns - Backend that was created on construction.
     */
    get backend(): Context.BackendType | undefined;
    /**
     * Provides a human-readable string of the backend.
     */
    get backendString(): string | undefined;
    /**
     * Provides an array of all extensions supported by the used WebGL1/2 context.
     */
    get extensions(): Array<string>;
    /**
     * Masquerade object applied to a context instance.
     */
    get mask(): ContextMasquerade | undefined;
    /**
     * Access to either the WebGLRenderingContext or WebGL2RenderingContext.
     */
    get gl(): any;
    /**
     * WebGL2 facade for WebGL2 API like access to features mandatory to this engine.
     */
    get gl2facade(): GL2Facade;
    /**
     * True if the context is a WebGL1 context, otherwise false.
     */
    get isWebGL1(): boolean;
    /**
     * True if the context is a WebGL2 context, otherwise false.
     */
    get isWebGL2(): boolean;
    protected ANGLE_instanced_arrays: any;
    protected ANGLE_instanced_arrays_supported: boolean;
    get supportsInstancedArrays(): boolean;
    get instancedArrays(): any;
    protected EXT_blend_minmax: any;
    protected EXT_blend_minmax_supported: boolean;
    get supportsBlendMinmax(): boolean;
    get blendMinmax(): any;
    protected EXT_color_buffer_half_float: any;
    protected EXT_color_buffer_half_float_supported: boolean;
    get supportsColorBufferHalfFloat(): boolean;
    get colorBufferHalfFloat(): any;
    protected EXT_disjoint_timer_query: any;
    protected EXT_disjoint_timer_query_supported: boolean;
    get supportsDisjointTimerQuery(): boolean;
    get disjointTimerQuery(): any;
    protected EXT_disjoint_timer_query_webgl2: any;
    protected EXT_disjoint_timer_query_webgl2_supported: boolean;
    get supportsDisjointTimerQueryWebGL2(): boolean;
    get disjointTimerQueryWebGL2(): any;
    protected EXT_frag_depth: any;
    protected EXT_frag_depth_supported: boolean;
    get supportsFragDepth(): boolean;
    get fragDepth(): any;
    protected EXT_sRGB: any;
    protected EXT_sRGB_supported: boolean;
    get supportsSRGB(): boolean;
    get sRGB(): any;
    protected EXT_shader_texture_lod: any;
    protected EXT_shader_texture_lod_supported: boolean;
    get supportsShaderTextureLOD(): boolean;
    get shaderTextureLOD(): any;
    protected EXT_texture_filter_anisotropic: any;
    protected EXT_texture_filter_anisotropic_supported: boolean;
    get supportsTextureFilterAnisotropic(): boolean;
    get textureFilterAnisotropic(): any;
    protected OES_element_index_uint: any;
    protected OES_element_index_uint_supported: boolean;
    get supportsElementIndexUint(): boolean;
    get elementIndexUint(): any;
    protected OES_standard_derivatives: any;
    protected OES_standard_derivatives_supported: boolean;
    get supportsStandardDerivatives(): boolean;
    get standardDerivatives(): any;
    protected OES_texture_float: any;
    protected OES_texture_float_supported: boolean;
    get supportsTextureFloat(): boolean;
    get textureFloat(): any;
    protected OES_texture_float_linear: any;
    protected OES_texture_float_linear_supported: boolean;
    get supportsTextureFloatLinear(): boolean;
    get textureFloatLinear(): any;
    protected OES_texture_half_float: any;
    protected OES_texture_half_float_supported: boolean;
    get supportsTextureHalfFloat(): boolean;
    get textureHalfFloat(): any;
    protected OES_texture_half_float_linear: any;
    protected OES_texture_half_float_linear_supported: boolean;
    get supportsTextureHalfFloatLinear(): boolean;
    get textureHalfFloatLinear(): any;
    protected OES_vertex_array_object: any;
    protected OES_vertex_array_object_supported: boolean;
    get supportsVertexArrayObject(): boolean;
    get vertexArrayObject(): any;
    protected WEBGL_color_buffer_float: any;
    protected WEBGL_color_buffer_float_supported: boolean;
    protected EXT_color_buffer_float: any;
    protected EXT_color_buffer_float_supported: boolean;
    get supportsColorBufferFloat(): boolean | undefined;
    get colorBufferFloat(): any | undefined;
    protected WEBGL_compressed_texture_astc: any;
    protected WEBGL_compressed_texture_astc_supported: boolean;
    get supportsCompressedTextureASTC(): boolean;
    get compressedTextureASTC(): any;
    protected WEBGL_compressed_texture_atc: any;
    protected WEBGL_compressed_texture_atc_supported: boolean;
    get supportsCompressedTextureATC(): boolean;
    get compressedTextureATC(): any;
    protected WEBGL_compressed_texture_etc: any;
    protected WEBGL_compressed_texture_etc_supported: boolean;
    get supportsCompressedTextureETC(): boolean;
    get compressedTextureETC(): any;
    protected WEBGL_compressed_texture_etc1: any;
    protected WEBGL_compressed_texture_etc1_supported: boolean;
    get supportsCompressedTextureETC1(): boolean;
    get compressedTextureETC1(): any;
    protected WEBGL_compressed_texture_pvrtc: any;
    protected WEBGL_compressed_texture_pvrtc_supported: boolean;
    get supportsCompressedTexturePVRTC(): boolean;
    get compressedTexturePVRTC(): any;
    protected WEBGL_compressed_texture_s3tc: any;
    protected WEBGL_compressed_texture_s3tc_supported: boolean;
    get supportsCompressedTextureS3TC(): boolean;
    get compressedTextureS3TC(): any;
    protected WEBGL_compressed_texture_s3tc_srgb: any;
    protected WEBGL_compressed_texture_s3tc_srgb_supported: boolean;
    get supportsCompressedTextureS3TCSRGB(): boolean;
    get compressedTextureS3TCSRGB(): any;
    protected WEBGL_debug_renderer_info: any;
    protected WEBGL_debug_renderer_info_supported: boolean;
    get supportsDebugRendererInfo(): boolean;
    get debugRendererInfo(): any;
    protected WEBGL_debug_shaders: any;
    protected WEBGL_debug_shaders_supported: boolean;
    get supportsDebugShaders(): boolean;
    get debugShaders(): any;
    protected WEBGL_depth_texture: any;
    protected WEBGL_depth_texture_supported: boolean;
    get supportsDepthTexture(): boolean;
    get depthTexture(): any;
    protected WEBGL_draw_buffers: any;
    protected WEBGL_draw_buffers_supported: boolean;
    get supportsDrawBuffers(): boolean;
    get drawBuffers(): any;
    protected WEBGL_lose_context: any;
    protected WEBGL_lose_context_supported: boolean;
    get supportsLoseContext(): boolean;
    get loseContext(): any;
    /**
     * True if WebGL2 blitFramebuffer is supported, false otherwise. This is experimental technology.
     */
    get supportsBlitFramebuffer(): boolean;
    /**
     * True if WebGL2 readBuffer is supported, false otherwise. This is experimental technology.
     */
    get supportsReadBuffer(): boolean;
    /**
     * True if WebGL2 texImage3D draft is supported, false otherwise. This is experimental technology.
     */
    get supportsTexImage3D(): boolean;
    param(pname: GLenum): any;
    /**
     * Provides the context's extension hash. The hash can be used for context masquerade.
     */
    hash(): string;
    /**
     * Queries various parameters (depending on the type of context and support of extensions) and returns them as
     * formatted string.
     * @returns - Array of 2-tuple containing (1) the queried enum as string and (2) the resulting parameter value.
     */
    about(): Array<[string, number | string]>;
    /**
     * Creates a well formated about string, e.g., for logging.
     */
    aboutString(): string;
    /**
     * Logs a well formated list of all queried about params (names and associated values).
     * @param verbosity - Log verbosity that is to be used for logging.
     */
    logAbout(verbosity?: LogLevel): void;
    /**
     * Invokes `logAbout` @see{@link logAbout}) iff the given statement has resolved to true.
     * @param statement - Result of an expression expected to be true in order to invoke logPerformanceStop.
     * @param verbosity - Log verbosity that is to be used for logging.
     */
    logAboutIf(statement: boolean, verbosity?: LogLevel): void;
    /**
     * Provides the size in bytes of certain WebGL format enumerator. Please note that some byte sizes might vary based
     * on context attributes or the bound render, thus, DEPTH_COMPONENT and DEPTH_STENCIL are not covered by this
     * function. @see {@link byteSizeOfFormat}
     */
    byteSizeOfFormat(format: GLenum): number;
}
export declare namespace Context {
    /**
     * Supported OpenGL backend types.
     */
    enum BackendType {
        Invalid = "invalid",
        WebGL1 = "webgl1",
        WebGL2 = "webgl2"
    }
    /**
     * The list of valid backend identifiers that can be requested and matched to backend types.
     * List adopted from https://developer.mozilla.org/de/docs/Web/API/HTMLCanvasElement/getContext.
     */
    enum BackendRequestType {
        auto = "auto",
        webgl = "webgl",
        experimental = "experimental-webgl",
        webgl1 = "webgl1",
        experimental1 = "experimental-webgl1",
        webgl2 = "webgl2",
        experimental2 = "experimental-webgl2"
    }
}
