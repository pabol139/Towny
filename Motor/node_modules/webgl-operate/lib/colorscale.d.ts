import { Color } from './color';
export declare class ColorScale {
    /**
     * Color scale preset file schema.
     */
    private static readonly SCHEMA;
    /** @see{@link hint} */
    protected _hint: ColorScale.InterpolationHint;
    /** @ee{@link colors} */
    protected _colors: Color[];
    /** @see{@link invert} */
    protected _inverted: boolean;
    /**
     * Returns the stride for interleaved arrays of color components based on the array type.
     * @param type - One of the supported color array types.
     */
    protected static stride(type: ColorScale.ArrayType): number;
    /**
     * Fetches a color schema file, and, if successful, picks a preset for the specified number of steps. If the named
     * preset cannot be found, a list of all available presets within the file is logged and undefined is returned. If
     * the preset does not specify exact colors for the requested number of steps, the color array with the most colors
     * and linear interpolation in CIE-LAB is used to generate the scale.
     *
     * The following preset libraries are included within webgl-operate but are required to be loaded dynamically (in
     * order to reduce bundle size and memory use):
     * ```
     * ColorScale.fromPreset('./colorbrewer.json', 'YlGnBu', 7);
     * ColorScale.fromPreset('./smithwalt.json', 'viridis', 16);
     * ```
     * And resolving the promise:
     * ```
     * const scale: ColorScale | undefined = undefined;
     * ColorScale.fromPreset('./data/colorbrewer.json', 'YlGnBu', 5).then((value) => scale = value);
     * ```
     * @param url - Uniform resource locator string referencing a json file complying to the JSON color schema.
     * @param preset - Name of a preset to choose from the json file.
     * @param stepCount - Number of steps to be used for the resulting color scheme.
     * @returns - Undefined if loading and validating the json failed or the preset was not found. Else, a color scale.
     */
    static fromPreset(url: string, preset: string, stepCount: number): Promise<ColorScale>;
    /**
     * Creates a color scale from a set of colors and (optional) positions for a specific step count. If no positions
     * are specified, the colors are spread equally. A step count of 1 returns the first color.
     * @param interleavedColorComponents - Interleaved array of color components, e.g., red, green, and blue.
     * @param type - The array type specifying the number of subsequent color components for each color.
     * @param stepCount - Number of colors to be computed from the color scale.
     * @param positions - Interleaved array of positions, matching the length of the color array divided by stride.
     * @returns - A color scale of fixed number and position of colors for index and linear interpolation access.
     */
    static fromArray(interleavedColorComponents: Array<number>, type: ColorScale.ArrayType, stepCount: number, positions?: Array<number>): ColorScale;
    /**
     * Queries the color at a given position by identifying the adjacent stops (lower and upper bound) and either
     * interpolating between these or picking the nearest of both. In case no stop exists, a default color will be
     * returned. If only one color exists, this color is always returned no matter the position. If the position is
     * out of bounds, either the first or last stop's color is returned.
     * @param position - Position in [0.0, 1.0] to linear interpolate the color at.
     * @param space - The color space that is to be used for linear interpolation of two colors.
     * @returns - Color, depending on the gradient type either linearly or nearest filtered color.
     */
    lerp(position: number, space?: Color.Space): Color | undefined;
    /**
     * Returns the color with specified index. If the index is out of bounds, undefined is returned. Alternatively, the
     * color array can be used directly @see{@link colors}.
     * @param index - Index of the color to access.
     */
    color(index: number): Color | undefined;
    /**
     * Returns the array containing the colors of the color scale.
     */
    get colors(): Array<Color>;
    set colors(colors: Array<Color>);
    /**
     * The interpolation hint used when accessing a color using interpolation, e.g., @see{@link lerp}.
     */
    set hint(hint: ColorScale.InterpolationHint);
    get hint(): ColorScale.InterpolationHint;
    /**
     * Provides read access to the number of colors of this scale. This is a shortcut for this.colors.length.
     */
    get length(): number;
    /**
     * Whether or not the scale was inverted based on its initial state.
     */
    get inverted(): boolean;
    /**
     * Inverts the color scale. Whether or not the scale is inverted can be checked using the
     * inverted read-only property (@link inverted).
     */
    invert(): void;
    /**
     * Converts the color scale into an array of interleaved unsigned int values of the requested color space.
     * @param space - Color space that is to be used for the array.
     * @param alpha - Whether or not alpha is to be included.
     */
    bitsUI8(space?: Color.Space, alpha?: boolean): Uint8Array;
    /**
     * Converts the color scale into an array of interleaved float values of the requested color space.
     * @param space - Color space that is to be used for the array.
     * @param alpha - Whether or not alpha is to be included.
     */
    bitsF32(space?: Color.Space, alpha?: boolean): Float32Array;
}
export declare namespace ColorScale {
    /**
     * Color interpolation type for a color scale.
     */
    enum InterpolationHint {
        Linear = "linear",
        Nearest = "nearest"
    }
    enum ScaleType {
        sequential = "sequential",
        diverging = "diverging",
        qualitative = "qualitative"
    }
    enum ArrayType {
        RGB = "rgb",
        RGBf = "rgbf",
        RGBA = "rgba",
        RGBAf = "rgbaf"
    }
    interface Preset {
        identifier: string;
        type: ScaleType | undefined;
        format: ArrayType;
        colors: Array<Array<number>>;
        positions: Array<Array<number>> | undefined;
    }
}
