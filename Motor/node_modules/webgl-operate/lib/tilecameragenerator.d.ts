import { vec4 } from 'gl-matrix';
import { Camera } from './camera';
import { GLsizei2, GLsizei4 } from './tuples';
/**
 * Support Class that wraps the calculation of camera tiling and iteration with various algorithms
 * by giving access to an adjusted camera which NDC-Coordinates match the current tile index.
 * Iteration can be done manually (variant: 1) or automatically (variant: 2).
 * It is intended to be used like:
 *
 * tileCameraGenerator = new TileCameraGenerator();
 * tileCameraGenerator.sourceCamera = camera;
 * tileCameraGenerator.sourceViewport = canvasSize;
 * tileCameraGenerator.tileSize = [128, 128];
 * tileCameraGenerator.algorithm = TileCameraGenerator.Algorithm.ScanLine;
 * let offset: [number, number];
 *
 * iteration variant 1:
 * for (let i = 0; i < tileCameraGenerator.numberOfTiles(); ++i){
 *      tileCameraGenerator.tile = i; // property
 *      tileCameraGenerator.update();
 *      offset = tileCameraGenerator.offset;
 *      "render camera"
 * }
 *
 * iteration variant 2:
 * while(tileCameraGenerator.nextTile()){
 *      offset = tileCameraGenerator.offset;
 *      "render"
 * }
 * // reset generator
 * tileCameraGenerator.reset();
 *
 * NOTE: Use `sourceCameraChanged` if the source camera is altered.
 */
export declare class TileCameraGenerator {
    /** @see {@link sourceCamera} */
    protected _sourceCamera: Camera | undefined;
    /** @see {@link sourceViewport} */
    protected _sourceViewport: GLsizei2 | undefined;
    /** @see {@link tileSize} */
    protected _tileSize: GLsizei2;
    /** @see {@link padding} */
    protected _padding: vec4;
    /** @see {@link tile} */
    protected _tile: number;
    /** @see {@link eye} */
    protected _camera: Camera | undefined;
    /** @see {@link algorithm} */
    protected _algorithm: TileCameraGenerator.Algorithm;
    protected _valid: boolean;
    protected _offset: GLsizei2;
    protected _indices: Uint16Array;
    /**
     * Recursively fills the interleaved indices using the Hilbert Curve. This method is not intended to be used
     * directly. Use generateHilbertIndices {@link generateHilbertIndices} instead.
     */
    protected static hilbertIndices(indices: Uint16Array, numX: number, numY: number, x: number, y: number, xi: number, xj: number, yi: number, yj: number, depth: number, hilbertIndex: number): number;
    /**
     * Fills the iterationAlgorithmIndices with the table indices
     * from the HilbertCurve-Iteration-Algorithm.
     */
    static generateHilbertIndices(indices: Uint16Array, numX: number, numY: number): void;
    /**
     * Generates interleaved table indices using the ZCurve-Iteration-Algorithm.
     */
    static generateScanLineIndices(indices: Uint16Array, numX: number, numY: number): void;
    /**
     * Fills the sequence/array of indices with the table indices from the ZCurve-Iteration-Algorithm.
     */
    static generateZCurveIndices(indices: Uint16Array, numX: number, numY: number): void;
    protected invalidate(clearIndices: boolean): void;
    /**
     * Ensures that the indices are available. If not, indices using the algorithm set will be generated.
     */
    protected ensureValidIterationIndices(): void;
    /**
     * Converts the tile index from the selected Algorithm to table indices.
     * @returns - The converted tile index.
     */
    protected tableIndices(): GLsizei2;
    /**
     * Returns the padded tileSize.
     * @returns - The padded tileSize.
     */
    protected getPaddedTileSize(): [number, number];
    /**
     * Used for Iterator behavior. It sets the tile to 0 (first tile) if the value of tile is negative
     * and therefore initiates the iteration.
     * Otherwise it increments the tile and calls update to directly change the camera.
     * If the tile index would get out of range it returns false to indicate, that all tiles were rendered.
     * @returns - If the camera has been set to a next tile.
     */
    nextTile(): boolean;
    /**
     * Returns if tiles still need to be rendered.
     */
    hasNextTile(): boolean;
    /**
     * Resets the tile index to prepare the generator for the next rendering.
     * Should be called after iteration with nextTile().
     */
    reset(): void;
    /**
     * Reassigns all values from the source camera to the tile camera, e.g., when the source camera is altered.
     */
    sourceCameraChanged(): void;
    /**
     * Updates the camera view frustum to current tile based on
     * the sourceViewport, tileSize and the padding.
     * If the tile is less than zero, the camera is set to the first tile.
     * If the tile is too high, the camera is not updated and remains in the last valid state.
     * @returns - the offset of the new camera tile.
     */
    update(): GLsizei2;
    get valid(): boolean;
    /**
     * Returns the number of tiles along the x-axis based on the number of tiles that fit inside the horizontal extent
     * of the source camera's viewport.
     * @returns - The number of tiles along the x-axis.
     */
    get numXTiles(): number;
    /**
     * Returns the number of tiles along the y-axis based on the number of tiles that fit inside the vertical extent
     * of the source camera's viewport.
     * @returns - The number of tiles along the y-axis.
     */
    get numYTiles(): number;
    /**
     * Returns the total number of tiles
     * based on the how many of tileSize fit inside the sourceViewport.
     * @returns - The total number of tiles.
     */
    get numTiles(): number;
    /**
     * Returns the offset of the current tile. The padding is not included in the offset.
     * @returns - Current tile offset.
     */
    get offset(): GLsizei2;
    /**
     * Read-only access to the tiled camera that has the viewport of the current tile of the input/source camera.
     * @returns - The reference to the tile viewing camera.
     */
    get camera(): Camera | undefined;
    /**
     * Creates a 4-tuple with x0, y0, and width and height of the viewport for the current tile and camera.
     * @returns - 4-tuple with [x0, y0, width, height] based on the current tile.
     */
    get viewport(): GLsizei4;
    /**
     * Returns the sourceCamera which viewport should be divided in tiles.
     * If the sourceCamera has not been set, it returns a default camera.
     * @returns - The sourceCamera which viewport should be divided in tiles.
     */
    get sourceCamera(): Camera | undefined;
    /**
     * Assigns the input camera whose viewport will be divided in tiles. Additionally it creates a deep copy of the
     * input camera which is used as the tiled camera {@link camera}.
     * @param camera - The input camera whose viewport will be divided in tiles.
     */
    set sourceCamera(camera: Camera | undefined);
    /**
     * Returns the current tile index.
     * @returns - The current tile index.
     */
    get tile(): number;
    /**
     * Sets the current tile index.
     * @param index - The new index.
     */
    set tile(index: GLsizei);
    /**
     * Returns the size of the original viewport
     * which should be divided in tiles based on the tile size.
     * If the viewport has not been set, it returns [-1, -1].
     * @returns - Size of the Viewport.
     */
    get sourceViewport(): GLsizei2 | undefined;
    /**
     * Sets the size of the viewport from the sourceCamera.
     * It checks if the sourceViewport is compatible with the selected algorithm
     * and eventually adjusts the tileSize to match the conditions of the algorithm.
     */
    set sourceViewport(viewport: GLsizei2 | undefined);
    /**
     * Returns the tileSize.
     * @returns - [-1, -1] as invalid.
     */
    get tileSize(): GLsizei2;
    /**
     * Sets the tileSize. The tileSize eventually changes to match the selected algorithms constraints.
     */
    set tileSize(tileSize: GLsizei2);
    /**
     * Returns the padding per tile in CSS order: top, right, bottom, left. The standard is (0, 0, 0, 0).
     */
    get padding(): vec4;
    /**
     * Stets the padding per tile in CSS order: top, right, bottom, left. The standard is (0, 0, 0, 0).
     */
    set padding(padding: vec4);
    /**
     * Returns the selected IterationAlgorithm which determines the sequence in which the tiles are rendered.
     */
    get algorithm(): TileCameraGenerator.Algorithm;
    /**
     * Sets the selected IterationAlgorithm which determines the order in which the tiles are rendered. The default is
     * `ScanLine`. If needed, it automatically adjusts the tileSize to match the new algorithm.
     */
    set algorithm(algorithm: TileCameraGenerator.Algorithm);
}
/**
 * The enum that is used to select one of the different algorithm.
 */
export declare namespace TileCameraGenerator {
    enum Algorithm {
        /**
         * ScanLine conditions: none.
         */
        ScanLine = "scanline",
        /**
         * HilbertCurve conditions: Both numberOfXTiles, numberOfYTiles need to be equal and need to be a power of two.
         * In the case that the condition is not satisfied the next higher number than numberOfTilesX/Y that is power
         * of two is calculated. The Iteration will be calculated with this number and tiles that lay outside the
         * viewport are skipped.
         */
        HilbertCurve = "hilbertcurve",
        /**
         * ZCurve conditions: Both numberOfXTiles, numberOfYTiles need to be equal and need to be a power of two. In
         * the case that the condition is not satisfied the next higher number than numberOfTilesX/Y that is power of
         * two is calculated. The Iteration will be calculated with this number and tiles that lay outside the
         * viewport are skipped.
         */
        ZCurve = "zcurve"
    }
}
