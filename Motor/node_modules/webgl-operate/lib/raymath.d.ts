import { mat4, vec2, vec3 } from 'gl-matrix';
import { Camera } from './camera';
declare namespace ray_math {
    /**
     * Lots of variables that represent components of other variables or are transformed.
     * For these I (dl) prefer, e.g.,  _component or _transformation notation
     */
    /**
     * Computes the intersection point of a given ray and a circle at [0.0, 0.0] and a given radius.
     * @param ray0 - Start point of a ray.
     * @param ray1 - Far point of a ray, used to derive the ray's direction.
     * @param radius - Radius of the circle to test for intersection with.
     * @returns The intersection point of the given ray and a circle, undefined if no intersection exists.
     */
    function rayCircleIntersection(ray0: vec2, ray1: vec2, radius?: number): vec2 | undefined;
    /**
     * Computes the intersection point of a ray starting at a given point and pointing to the center of an axis-aligned
     * square of a given side length.
     * @param point - Starting point used to derive a ray for intersection.
     * @param edgeLength - Side length of the square.
     * @returns - The intersection point of the square and the derived ray.
     */
    function pointSquareIntersection(point: vec2, edgeLength?: number): vec2;
    /**
     * Computes the intersection of a ray with an axis-aligned square at [0.0, 0.0] with side length of 2 * halfLength.
     * @param ray0 - Start point of a ray.
     * @param ray1 - Far point of a ray, used to derive the ray's direction.
     * @returns - The intersection point of the square and the ray.
     */
    function raySquareIntersection(ray0: vec2, ray1: vec2, halfLength?: number): Array<number>;
    /**
     * Computes the intersection of a ray with a line.
     * @param ray0 - Start point of a ray.
     * @param ray1 - Far point of a ray, used to derive the ray direction.
     * @param line0 - Start point of a line.
     * @param line1 - End point of a line.
     * @returns - If ray intersects, a 2-tuple of intersection point and t (ray0 + t + ray1) is returned.
     */
    function rayLineIntersection(ray0: vec2, ray1: vec2, line0: vec2, line1: vec2): [vec2, number] | undefined;
    /**
     * Computes the intersection point of a given ray and a given plane (rooted at [ 0, 0, 0 ]).
     * t = -(dot(plane.xyz, origin) + plane.w) / dot(plane.xyz, ray);
     * The ray intersects when (t > 0.0) && (t < tm) is true.
     * @param ray0 - Start point of a ray.
     * @param ray1 - Far point of a ray, used to derive the ray direction.
     * @param origin - Point on a plane with origin [ 0, 0, 0 ].
     * @param normal - Normal of the plane with origin [ 0, 0, 0 ].
     * @returns - If ray intersects, the intersection point on the plane if the plane was hit.
     */
    function rayPlaneIntersection(ray0: vec3, ray1: vec3, origin?: vec3, normal?: vec3): vec3 | undefined;
    /**
     * Computes the intersection point of a given ray and a given sphere.
     * t = -(dot(plane.xyz, origin) + plane.w) / dot(plane.xyz, ray);
     * The ray intersects when (t > 0.0) && (t < tm) is true.
     * @param ray0 - Start point of a ray.
     * @param ray1 - Far point of a ray, used to derive the ray direction.
     * @param origin - Location of the sphere.
     * @param radius - Radius of the sphere.
     * @returns - If ray intersects, the intersection point on the plane if the plane was hit.
     */
    function raySphereIntersection(ray0: vec3, ray1: vec3, origin?: vec3, radius?: number): vec3 | undefined;
    /**
     * Computes the intersection point of a given ray and a given plane (origin [ 0, 0, 0 ]). The intersection point,
     * however, is constrained to a tube of a given radius. The computation is currently limited to a tube
     * on the plane y = 0 with origin in [0.0, 0.0, 0.0], extending towards [0.0, 1.0, 0.0].
     * @param ray0 - Start point of a ray.
     * @param ray1 - Far point of a ray, used to derive the ray direction.
     * @param radius - Constrain intersection point to be within a tube of this radius.
     * @returns - The intersection point on the plane if the plane was hit, undefined otherwise.
     */
    function rayPlaneIntersection_tube(ray0: vec3, ray1: vec3, radius?: number): vec3 | undefined;
    /**
     * Evaluates whether or not a given point is within a square of a given edge length.
     * @param point - Point to check the within-square-status for.
     * @param halfLength - Half of the side length of the square.
     * @returns - Whether or not the given point is within an axis aligned square at [0.0, 0.0] and edge length.
     */
    function isPointWithinSquare(point: vec2, halfLength?: number): boolean;
    /**
     * Evaluates whether or not a given point is within the NDC-space (normalized device coordinates) after being
     * transformed by a view projection matrix.
     * @param viewProjection - (Model) view projection matrix to transform the point with.
     * @param point - Point that is to be transformed
     * @returns True if the point should be visible (within NDC), false otherwise.
     */
    function isPointWithinNDC(viewProjection: mat4, point: vec3): boolean;
    /**
     * Computes the shortest distance of a point to a ray (closest point on ray distance).
     * @param ray0 - Start point of a ray.
     * @param ray1 - Far point of a ray, used to derive the ray direction.
     * @param point - Point to compute the distance for.
     * @returns - Distance of the closest point on a ray to a point.
     */
    function distancePointToRay(ray0: vec3, ray1: vec3, point: vec3): number;
    /**
     * Computes a new eye coordinate for the camera that should have the given point within view. The eye is only
     * modified with respect to its distance to the camera's center (on the camera look-at ray).
     * @param camera - Camera as base constraint for the eye movement (only distance to center is changed).
     * @param point - Point to adjust the camera position for.
     * @returns - Eye coordinate for the given camera that should have the given point within view.
     */
    function eyeWithPointInView(camera: Camera, point: vec3): vec3;
}
export = ray_math;
